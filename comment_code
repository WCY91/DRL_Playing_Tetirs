# --- åŸºæœ¬å¼•å…¥ ---
import numpy as np               # ç”¨æ–¼æ•¸å€¼è¨ˆç®—ï¼Œç‰¹åˆ¥æ˜¯é™£åˆ—æ“ä½œ
import socket                    # ç”¨æ–¼å»ºç«‹ TCP/IP socket é€£ç·šï¼Œèˆ‡ Java Server æºé€š
import cv2                       # OpenCV å‡½å¼åº«ï¼Œç”¨æ–¼å½±åƒè™•ç† (è®€å–ã€ç¸®æ”¾ã€é¡è‰²è½‰æ›)
# import matplotlib.pyplot as plt # ç¹ªåœ–ç”¨ï¼Œæ­¤è™•éæ ¸å¿ƒåŠŸèƒ½
import subprocess                # ç”¨æ–¼åŸ·è¡Œå¤–éƒ¨å‘½ä»¤ï¼Œä¾‹å¦‚å•Ÿå‹• Java Server çš„ .jar æª”
import os                        # ç”¨æ–¼æ“ä½œæª”æ¡ˆç³»çµ±ï¼Œä¾‹å¦‚æª¢æŸ¥æª”æ¡ˆæ˜¯å¦å­˜åœ¨ã€å»ºç«‹ç›®éŒ„
import shutil                    # ç”¨æ–¼é«˜éšæª”æ¡ˆæ“ä½œ (æ­¤è™•æœªä½¿ç”¨ï¼Œä½†å¯èƒ½ç”¨æ–¼æ¸…ç†)
import glob                      # ç”¨æ–¼å°‹æ‰¾ç¬¦åˆç‰¹å®šè¦å‰‡çš„æª”æ¡ˆè·¯å¾‘ (ç”¨æ–¼ç”Ÿæˆ GIF)
import imageio                   # ç”¨æ–¼è®€å¯«å¤šç¨®å½±åƒæ ¼å¼ï¼Œç‰¹åˆ¥æ˜¯ç”Ÿæˆ GIF
import gymnasium as gym          # OpenAI Gym çš„å¾Œç¹¼è€…ï¼Œæä¾›æ¨™æº–çš„å¼·åŒ–å­¸ç¿’ç’°å¢ƒä»‹é¢
from gymnasium import spaces     # Gym çš„æ¨¡çµ„ï¼Œç”¨æ–¼å®šç¾©è§€å¯Ÿç©ºé–“å’Œå‹•ä½œç©ºé–“
# from stable_baselines3.common.env_checker import check_env # ç”¨æ–¼æª¢æŸ¥è‡ªè¨‚ç’°å¢ƒæ˜¯å¦ç¬¦åˆ Gym æ¨™æº– (å° VecEnv ç„¡æ•ˆ)
from stable_baselines3 import DQN # Stable Baselines3 æä¾›çš„ DQN æ¼”ç®—æ³•å¯¦ç¾
# from stable_baselines3.common.env_util import make_vec_env # ç”¨æ–¼å»ºç«‹å¤šå€‹ä¸¦è¡Œç’°å¢ƒ (æ­¤è™•æœªä½¿ç”¨)
from stable_baselines3.common.vec_env import VecNormalize, VecFrameStack, DummyVecEnv # SB3 æä¾›çš„ç’°å¢ƒåŒ…è£å™¨
from IPython.display import FileLink, display # åœ¨ Jupyter ç’°å¢ƒä¸­é¡¯ç¤ºæª”æ¡ˆä¸‹è¼‰é€£çµ
# from stable_baselines3.common.callbacks import BaseCallback # è‡ªè¨‚å›å‘¼å‡½æ•¸çš„åŸºåº•é¡åˆ¥ (è¢« WandbCallback å–ä»£)
import torch                     # PyTorch å‡½å¼åº«ï¼ŒSB3 åº•å±¤ä½¿ç”¨å®ƒä¾†å»ºç«‹å’Œè¨“ç·´ç¥ç¶“ç¶²è·¯
import time                      # æä¾›æ™‚é–“ç›¸é—œåŠŸèƒ½ï¼Œä¾‹å¦‚æš«åœã€ç²å–æ™‚é–“æˆ³
import pygame                    # ç”¨æ–¼å»ºç«‹éŠæˆ²è¦–çª—å’Œåœ–å½¢åŒ–é¡¯ç¤º (åœ¨ TetrisEnv çš„ render ä¸­ä½¿ç”¨)

# --- Wandb Setup ---
# import os                      # (ä¸Šé¢å·²å¼•å…¥)
import wandb                     # Weights & Biases å‡½å¼åº«ï¼Œç”¨æ–¼å¯¦é©—è¿½è¹¤å’Œè¦–è¦ºåŒ–
from kaggle_secrets import UserSecretsClient # Kaggle å¹³å°æä¾›çš„è®€å–ç§å¯†è³‡è¨Š (API Key) çš„æ–¹å¼
from wandb.integration.sb3 import WandbCallback # Wandb æä¾›çš„èˆ‡ SB3 æ•´åˆçš„å›å‘¼å‡½æ•¸

# --- çµ„æ…‹è¨­å®š ---
# åœ¨é€™è£¡è¨­å®šä½ çš„å­¸è™Ÿï¼Œç”¨æ–¼å„²å­˜æª”æ¡ˆçš„æª”å
STUDENT_ID = "113598065"
# è¨­å®šç¸½è¨“ç·´æ­¥æ•¸ (Timesteps)ï¼Œé€™å€‹æ•¸å€¼éœ€è¦è¶³å¤ å¤§æ‰èƒ½è®“æ¨¡å‹å­¸æœƒ
# æ ¹æ“šä½ çš„ç¡¬é«”å’Œè€å¿ƒèª¿æ•´ï¼Œä¾‹å¦‚ 100è¬ã€200è¬ã€500è¬...
TOTAL_TIMESTEPS = 500000 # å…ˆè¨­ 50 è¬æ­¥æ¸¬è©¦ï¼Œå¯¦éš›è¨“ç·´å»ºè­°è‡³å°‘ 100 è¬ä»¥ä¸Š

# --- Wandb ç™»å…¥èˆ‡åˆå§‹åŒ– ---
try:
    # å˜—è©¦å¾ Kaggle Secrets è®€å– Wandb API Key
    user_secrets = UserSecretsClient()
    WANDB_API_KEY = user_secrets.get_secret("WANDB_API_KEY")
    # è¨­å®šç’°å¢ƒè®Šæ•¸ï¼Œwandb.login() æœƒè‡ªå‹•è®€å–
    os.environ["WANDB_API_KEY"] = WANDB_API_KEY
    wandb.login() # ç™»å…¥ Wandb
    wandb_enabled = True # æ¨™è¨˜ Wandb å·²å•Ÿç”¨
except Exception as e:
    # å¦‚æœè®€å– Secret æˆ–ç™»å…¥å¤±æ•— (ä¾‹å¦‚åœ¨æœ¬æ©Ÿæˆ–æ²’æœ‰è¨­å®š Secret)ï¼Œå‰‡ä¸ä½¿ç”¨ Wandb
    print(f"Wandb login failed (running without secrets?): {e}. Running without Wandb logging.")
    wandb_enabled = False
    WANDB_API_KEY = None # ç¢ºä¿ API Key æ˜¯ None

# å¦‚æœ Wandb æˆåŠŸå•Ÿç”¨ï¼Œå‰‡åˆå§‹åŒ–ä¸€å€‹ Wandb run
if wandb_enabled:
    run = wandb.init(
        project="tetris-training-improved", # Wandb å°ˆæ¡ˆåç¨±
        entity="t113598065-ntut-edu-tw",   # ä½ çš„ Wandb å¸³è™Ÿæˆ–åœ˜éšŠåç¨±
        sync_tensorboard=True,     # è‡ªå‹•ä¸Šå‚³ SB3 ç”¢ç”Ÿçš„ TensorBoard æ—¥èªŒ
        monitor_gym=True,          # è‡ªå‹•ç›£æ§ Gym ç’°å¢ƒ (æœƒä¸Šå‚³å½±ç‰‡ã€åœ–è¡¨ç­‰)
        save_code=True,            # å°‡åŸ·è¡Œæ™‚çš„ç¨‹å¼ç¢¼å„²å­˜åˆ° Wandb
        config={ # è¨˜éŒ„é€™æ¬¡åŸ·è¡Œçš„è¶…åƒæ•¸ï¼Œæ–¹ä¾¿è¿½è¹¤å’Œæ¯”è¼ƒ
            "policy_type": "CnnPolicy",          # ä½¿ç”¨çš„ç­–ç•¥é¡å‹ (å·ç©ç¥ç¶“ç¶²è·¯)
            "total_timesteps": TOTAL_TIMESTEPS, # ç¸½è¨“ç·´æ­¥æ•¸
            "env_id": "TetrisEnv-v1",           # ç’°å¢ƒåç¨± (è‡ªè¨‚)
            "gamma": 0.99,                      # æŠ˜æ‰£å› å­ (Discount Factor)ï¼Œæœªä¾†çå‹µçš„é‡è¦æ€§
            "learning_rate": 1e-4,              # å­¸ç¿’ç‡ï¼Œæ¨¡å‹æ›´æ–°çš„å¹…åº¦
            "buffer_size": 300000,              # ç¶“é©—å›æ”¾ç·©è¡å€å¤§å° (Replay Buffer)
            "learning_starts": 10000,           # å¤šå°‘æ­¥ä¹‹å¾Œæ‰é–‹å§‹å­¸ç¿’
            "target_update_interval": 10000,    # ç›®æ¨™ç¶²è·¯ (Target Network) æ›´æ–°é »ç‡
            "exploration_fraction": 0.6,        # æ¢ç´¢ç‡å¾ 1.0 è¡°æ¸›åˆ°æœ€çµ‚å€¼æ‰€ä½”çš„è¨“ç·´æ­¥æ•¸æ¯”ä¾‹
            "exploration_final_eps": 0.05,      # æ¢ç´¢ç‡çš„æœ€çµ‚å€¼ (Epsilon)
            "batch_size": 32,                   # æ¯æ¬¡æ›´æ–°æ¨¡å‹æ™‚å¾ Replay Buffer å–æ¨£çš„æ•¸é‡
            "n_stack": 4,                       # VecFrameStack ä½¿ç”¨çš„å †ç–Šå¹€æ•¸
            "student_id": STUDENT_ID,           # è¨˜éŒ„å­¸è™Ÿ
        }
    )
    run_id = run.id # ç²å–é€™æ¬¡ Wandb run çš„å”¯ä¸€ IDï¼Œç”¨æ–¼æª”æ¡ˆå‘½å
else:
    run = None # Wandb æœªå•Ÿç”¨ï¼Œrun è¨­ç‚º None
    run_id = f"local_{int(time.time())}" # å»ºç«‹ä¸€å€‹åŸºæ–¼æ™‚é–“æˆ³çš„æœ¬åœ° ID

# --- æ—¥èªŒè¨˜éŒ„ ---
log_path = f"/kaggle/working/tetris_train_log_{run_id}.txt" # æ—¥èªŒæª”è·¯å¾‘
def write_log(message, exc_info=False): # å¢åŠ  exc_info åƒæ•¸ç”¨æ–¼è¨˜éŒ„éŒ¯èª¤ç´°ç¯€
    """å°‡è¨Šæ¯é™„åŠ åˆ°æ—¥èªŒæª”æ¡ˆä¸¦åˆ—å°å‡ºä¾†ã€‚"""
    timestamp = time.strftime('%Y-%m-%d %H:%M:%S')
    log_message = f"{timestamp} - {message}"
    # å¦‚æœè¦æ±‚è¨˜éŒ„éŒ¯èª¤ç´°ç¯€ï¼ŒåŠ å…¥ Traceback
    if exc_info:
        import traceback
        log_message += "\n" + traceback.format_exc()
    try:
        with open(log_path, "a", encoding="utf-8") as f:
            f.write(log_message + "\n")
    except Exception as e:
        print(f"Error writing to log file {log_path}: {e}")
    print(log_message) # ç¸½æ˜¯åˆ—å°åˆ°æ§åˆ¶å°

# --- Java Server è™•ç† ---
def wait_for_tetris_server(ip="127.0.0.1", port=10612, timeout=60):
    """ç­‰å¾… Tetris TCP server è®Šå¾—å¯ç”¨ã€‚"""
    write_log(f"â³ ç­‰å¾… Tetris TCP server å•Ÿå‹•ä¸­ ({ip}:{port})...")
    start_time = time.time()
    while True:
        try:
            # å˜—è©¦å»ºç«‹ä¸€å€‹çŸ­æš«çš„ socket é€£ç·šä¾†æ¸¬è©¦ Server æ˜¯å¦å·²å•Ÿå‹•ä¸¦ç›£è½
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as test_sock:
                test_sock.settimeout(1.0) # è¨­å®šçŸ­è¶…æ™‚
                test_sock.connect((ip, port))
            write_log("âœ… Java TCP server æº–å‚™å®Œæˆï¼Œé€£ç·šæˆåŠŸ")
            return True # é€£ç·šæˆåŠŸï¼Œè¿”å› True
        except socket.error as e: # é€£ç·šå¤±æ•—
            if time.time() - start_time > timeout: # æª¢æŸ¥æ˜¯å¦å·²è¶…æ™‚
                write_log(f"âŒ ç­‰å¾… Java TCP server è¶…æ™‚ ({timeout}s)")
                return False # è¶…æ™‚ï¼Œè¿”å› False
            time.sleep(1.0) # ç­‰å¾… 1 ç§’å¾Œé‡è©¦

# --- å•Ÿå‹• Java Server ---
java_process = None # åˆå§‹åŒ– Java Process ç‰©ä»¶ç‚º None
try:
    write_log("ğŸš€ å˜—è©¦å•Ÿå‹• Java Tetris server...")
    jar_file = "TetrisTCPserver_v0.6.jar" # æŒ‡å®š JAR æª”å
    if not os.path.exists(jar_file): # æª¢æŸ¥æª”æ¡ˆæ˜¯å¦å­˜åœ¨
         write_log(f"âŒ éŒ¯èª¤: æ‰¾ä¸åˆ° JAR æª”æ¡ˆ '{jar_file}'ã€‚è«‹ç¢ºä¿å®ƒåœ¨å·¥ä½œç›®éŒ„ä¸­ã€‚")
         raise FileNotFoundError(f"JAR file '{jar_file}' not found.")

    # ä½¿ç”¨ subprocess.Popen å•Ÿå‹• Java é€²ç¨‹
    # stdout=subprocess.DEVNULL å’Œ stderr=subprocess.DEVNULL å¯ä»¥éš±è— Java Server çš„è¼¸å‡ºï¼Œè®“æ§åˆ¶å°æ›´ä¹¾æ·¨
    java_process = subprocess.Popen(
        ["java", "-jar", jar_file],
        stdout=subprocess.DEVNULL, # å°‡æ¨™æº–è¼¸å‡ºé‡å®šå‘åˆ°ç©ºè¨­å‚™
        stderr=subprocess.DEVNULL  # å°‡æ¨™æº–éŒ¯èª¤é‡å®šå‘åˆ°ç©ºè¨­å‚™
    )
    write_log(f"âœ… Java server process å•Ÿå‹• (PID: {java_process.pid})")
    # ç­‰å¾… Server çœŸæ­£å•Ÿå‹•å®Œæˆ
    if not wait_for_tetris_server():
        raise TimeoutError("Java server did not become available.") # å¦‚æœè¶…æ™‚å‰‡æ‹‹å‡ºéŒ¯èª¤

except Exception as e:
    # è™•ç†å•Ÿå‹•æˆ–ç­‰å¾…éç¨‹ä¸­çš„ä»»ä½•éŒ¯èª¤
    write_log(f"âŒ å•Ÿå‹•æˆ–ç­‰å¾… Java server æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
    # å¦‚æœé€²ç¨‹å·²å•Ÿå‹•ä½†é€£ç·šå¤±æ•—ï¼Œå˜—è©¦çµ‚æ­¢å®ƒ
    if java_process and java_process.poll() is None:
         write_log("   å˜—è©¦çµ‚æ­¢æœªæˆåŠŸé€£æ¥çš„ Java server process...")
         java_process.terminate() # å˜—è©¦æ­£å¸¸çµ‚æ­¢
         try:
             java_process.wait(timeout=2) # ç­‰å¾… 2 ç§’
         except subprocess.TimeoutExpired: # å¦‚æœç„¡æ³•æ­£å¸¸çµ‚æ­¢
             java_process.kill() # å¼·åˆ¶çµæŸ
    raise # å°‡éŒ¯èª¤é‡æ–°æ‹‹å‡ºï¼Œåœæ­¢è…³æœ¬åŸ·è¡Œ

# --- æª¢æŸ¥ GPU ---
if torch.cuda.is_available(): # æª¢æŸ¥ PyTorch æ˜¯å¦èƒ½åµæ¸¬åˆ° CUDA (NVIDIA GPU)
    device_name = torch.cuda.get_device_name(0) # ç²å– GPU åç¨±
    write_log(f"âœ… PyTorch is using GPU: {device_name}")
else:
    write_log("âš ï¸ PyTorch is using CPU. Training will be significantly slower.")

# ----------------------------
# å®šç¾© Tetris ç’°å¢ƒ (TetrisEnv Class)
# ----------------------------
class TetrisEnv(gym.Env):
    """è‡ªè¨‚çš„ Tetris ç’°å¢ƒï¼Œé€é TCP Socket èˆ‡ Java Server äº’å‹•ã€‚"""
    # metadata ç”¨æ–¼ Gym ç’°å¢ƒè¨»å†Šå’Œæ¸²æŸ“è¨­å®š
    metadata = {"render_modes": ["human", "rgb_array"], "render_fps": 30}
    # å®šç¾©ç’°å¢ƒå±¬æ€§ (å¸¸æ•¸)
    N_DISCRETE_ACTIONS = 5  # å‹•ä½œæ•¸é‡ (å·¦, å³, å·¦æ—‹, å³æ—‹, ä¸‹æ”¾)
    IMG_HEIGHT = 200        # Java Server åŸå§‹å½±åƒé«˜åº¦
    IMG_WIDTH = 100         # Java Server åŸå§‹å½±åƒå¯¬åº¦
    IMG_CHANNELS = 3        # Java Server åŸå§‹å½±åƒé€šé“æ•¸ (BGR)
    RESIZED_DIM = 84        # è™•ç†å¾Œè¼¸å…¥çµ¦ç¥ç¶“ç¶²è·¯çš„å½±åƒå¤§å° (é€šå¸¸ç”¨ 84x84)

    def __init__(self, host_ip="127.0.0.1", host_port=10612, render_mode=None):
        """ç’°å¢ƒåˆå§‹åŒ–å‡½å¼ã€‚"""
        super().__init__() # å‘¼å«çˆ¶é¡åˆ¥ (gym.Env) çš„åˆå§‹åŒ–
        self.render_mode = render_mode # è¨­å®šæ¸²æŸ“æ¨¡å¼ (human:é¡¯ç¤ºè¦–çª—, rgb_array:è¿”å›å½±åƒé™£åˆ—, None:ä¸æ¸²æŸ“)
        # å®šç¾©å‹•ä½œç©ºé–“ï¼šé›¢æ•£ç©ºé–“ï¼ŒåŒ…å« N_DISCRETE_ACTIONS å€‹å‹•ä½œ (0 åˆ° 4)
        self.action_space = spaces.Discrete(self.N_DISCRETE_ACTIONS)
        # å®šç¾©è§€å¯Ÿç©ºé–“ï¼šBox ç©ºé–“ï¼Œä»£è¡¨ä¸€å€‹å½±åƒ
        self.observation_space = spaces.Box(
            low=0, high=255,                          # åƒç´ å€¼ç¯„åœ (ç°åº¦åœ–)
            shape=(1, self.RESIZED_DIM, self.RESIZED_DIM), # å½¢ç‹€ (é€šé“æ•¸, é«˜, å¯¬)ï¼Œé€šé“æ•¸ç‚º 1 ä»£è¡¨ç°åº¦åœ–ï¼Œä¸”é€šé“åœ¨å‰ (PyTorch CNN è¦æ±‚)
            dtype=np.uint8                            # è³‡æ–™å‹æ…‹ç‚º 8 ä½å…ƒç„¡ç¬¦è™Ÿæ•´æ•¸
        )
        self.server_ip = host_ip     # Java Server IP
        self.server_port = host_port # Java Server Port
        self.client_sock = None      # åˆå§‹åŒ– Socket ç‰©ä»¶ç‚º None
        self._connect_socket()       # åœ¨åˆå§‹åŒ–æ™‚å°±å»ºç«‹ Socket é€£ç·š

        # --- å…§éƒ¨ç‹€æ…‹è®Šæ•¸ï¼Œç”¨æ–¼è¨ˆç®—çå‹µå’Œçµ±è¨ˆ ---
        self.lines_removed = 0      # ç´¯è¨ˆæ¶ˆé™¤çš„è¡Œæ•¸
        self.current_height = 0     # ç•¶å‰å †ç–Šçš„æœ€é«˜é«˜åº¦
        self.current_holes = 0      # ç•¶å‰ç›¤é¢ä¸Šçš„å­”æ´æ•¸é‡
        self.lifetime = 0           # ç•¶å‰é€™ä¸€å±€éŠæˆ²é€²è¡Œçš„æ­¥æ•¸
        # å„²å­˜æœ€å¾Œä¸€æ¬¡æ”¶åˆ°çš„è§€å¯Ÿå€¼ (è™•ç†å¾Œçš„ç°åº¦åœ–)ï¼Œç”¨æ–¼éŒ¯èª¤è™•ç†æˆ– reset
        self.last_observation = np.zeros(self.observation_space.shape, dtype=np.uint8)
        # å„²å­˜æœ€å¾Œä¸€æ¬¡æ”¶åˆ°çš„åŸå§‹æ¸²æŸ“å¹€ (BGR, Resized)ï¼Œç”¨æ–¼ render()
        self.last_raw_render_frame = np.zeros((self.RESIZED_DIM, self.RESIZED_DIM, 3), dtype=np.uint8)

        # --- çå‹µå¡‘å½¢ (Reward Shaping) ä¿‚æ•¸ (é€™äº›å€¼éå¸¸é—œéµï¼Œéœ€è¦æ ¹æ“šè¨“ç·´æ•ˆæœèª¿æ•´ï¼) ---
        self.reward_line_clear_coeff = 100.0   # æ¶ˆé™¤è¡Œçå‹µçš„åŸºç¤ä¿‚æ•¸ (ä¹˜ä»¥æ¶ˆé™¤è¡Œæ•¸çš„å¹³æ–¹)
        self.penalty_height_increase_coeff = 15.0 # é«˜åº¦å¢åŠ æ‡²ç½°çš„ä¿‚æ•¸
        self.penalty_hole_increase_coeff = 25.0   # å­”æ´å¢åŠ æ‡²ç½°çš„ä¿‚æ•¸
        self.penalty_step_coeff = 0.1             # æ¯èµ°ä¸€æ­¥çš„å¾®å°æ‡²ç½° (é¼“å‹µæ•ˆç‡)
        self.penalty_game_over_coeff = 500.0      # éŠæˆ²çµæŸçš„å·¨å¤§æ‡²ç½°

        # --- ç”¨æ–¼ Pygame æ¸²æŸ“çš„è®Šæ•¸ ---
        self.window_surface = None  # Pygame è¦–çª—è¡¨é¢
        self.clock = None           # Pygame æ™‚é˜ï¼Œç”¨æ–¼æ§åˆ¶å¹€ç‡
        self.is_pygame_initialized = False # è¿½è¹¤ Pygame æ˜¯å¦å·²åˆå§‹åŒ–

    def _initialize_pygame(self):
        """å¦‚æœå°šæœªåˆå§‹åŒ– Pygameï¼Œå‰‡é€²è¡Œåˆå§‹åŒ– (åƒ…åœ¨ human æ¨¡å¼éœ€è¦)ã€‚"""
        if not self.is_pygame_initialized and self.render_mode == "human":
            try:
                import pygame # åœ¨éœ€è¦æ™‚æ‰ import
                pygame.init() # åˆå§‹åŒ– Pygame æ‰€æœ‰æ¨¡çµ„
                pygame.display.init() # åˆå§‹åŒ–é¡¯ç¤ºæ¨¡çµ„
                # è¨­å®šè¦–çª—å¤§å° (æ”¾å¤§ä¸€é»æ¯”è¼ƒå¥½çœ‹)
                window_width = self.RESIZED_DIM * 4
                window_height = self.RESIZED_DIM * 4
                self.window_surface = pygame.display.set_mode((window_width, window_height))
                pygame.display.set_caption(f"Tetris Env ({self.server_ip}:{self.server_port})") # è¨­å®šè¦–çª—æ¨™é¡Œ
                self.clock = pygame.time.Clock() # å»ºç«‹æ™‚é˜ç‰©ä»¶
                self.is_pygame_initialized = True # æ¨™è¨˜å·²åˆå§‹åŒ–
                # write_log("   Pygame initialized for rendering.") # å¯é¸ï¼šæ—¥èªŒè¨˜éŒ„
            except ImportError: # å¦‚æœä½¿ç”¨è€…æ²’æœ‰å®‰è£ pygame
                write_log("âš ï¸ Pygame not installed, cannot use 'human' render mode.")
                self.render_mode = None # é—œé–‰ human æ¸²æŸ“æ¨¡å¼
            except Exception as e: # å…¶ä»– Pygame åˆå§‹åŒ–éŒ¯èª¤
                write_log(f"âš ï¸ Error initializing Pygame: {e}")
                self.render_mode = None

    def _connect_socket(self):
        """å»ºç«‹èˆ‡éŠæˆ²ä¼ºæœå™¨çš„ Socket é€£ç·šã€‚"""
        try:
            if self.client_sock: # å¦‚æœå·²å­˜åœ¨èˆŠé€£ç·šï¼Œå…ˆé—œé–‰
                self.client_sock.close()
            self.client_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # å»ºç«‹ TCP Socket
            self.client_sock.settimeout(10.0) # è¨­å®š Socket æ“ä½œçš„è¶…æ™‚æ™‚é–“ (10ç§’)
            self.client_sock.connect((self.server_ip, self.server_port)) # é€£ç·šåˆ° Server
        except socket.error as e: # è™•ç†é€£ç·šéŒ¯èª¤
            write_log(f"âŒ Socket connection error during connect: {e}")
            # æ‹‹å‡ºæ›´æ˜ç¢ºçš„éŒ¯èª¤é¡å‹ï¼ŒæŒ‡ç¤ºé€£ç·šå¤±æ•—
            raise ConnectionError(f"Failed to connect to Tetris server at {self.server_ip}:{self.server_port}")

    def _send_command(self, command: bytes):
        """å‘ä¼ºæœå™¨ç™¼é€æŒ‡ä»¤ï¼Œä¸¦è™•ç†æ½›åœ¨éŒ¯èª¤ã€‚"""
        if not self.client_sock: # æª¢æŸ¥ Socket æ˜¯å¦å·²é€£ç·š
             raise ConnectionError("Socket is not connected. Cannot send command.")
        try:
            self.client_sock.sendall(command) # ç™¼é€æ‰€æœ‰è³‡æ–™
        except socket.timeout: # è™•ç†è¶…æ™‚
            write_log("âŒ Socket timeout during send.")
            raise ConnectionAbortedError("Socket timeout during send")
        except socket.error as e: # è™•ç†å…¶ä»– Socket éŒ¯èª¤
            write_log(f"âŒ Socket error during send: {e}")
            raise ConnectionAbortedError(f"Socket error during send: {e}")

    def _receive_data(self, size):
        """å¾ä¼ºæœå™¨æ¥æ”¶æŒ‡å®šå¤§å°çš„è³‡æ–™ã€‚"""
        if not self.client_sock: # æª¢æŸ¥ Socket æ˜¯å¦å·²é€£ç·š
             raise ConnectionError("Socket is not connected. Cannot receive data.")
        data = b"" # åˆå§‹åŒ–æ¥æ”¶è³‡æ–™çš„ byte string
        try:
            self.client_sock.settimeout(10.0) # ç‚ºæ¥æ”¶è¨­å®šè¶…æ™‚
            while len(data) < size: # è¿´åœˆç›´åˆ°æ”¶åˆ°è¶³å¤ çš„è³‡æ–™
                # å˜—è©¦æ¥æ”¶å‰©é¤˜æ‰€éœ€çš„è³‡æ–™é‡
                chunk = self.client_sock.recv(size - len(data))
                if not chunk: # å¦‚æœæ”¶åˆ°ç©º chunkï¼Œè¡¨ç¤ºé€£ç·šå¯èƒ½å·²ä¸­æ–·
                    write_log("âŒ Socket connection broken during receive (received empty chunk).")
                    raise ConnectionAbortedError("Socket connection broken")
                data += chunk # å°‡æ”¶åˆ°çš„ chunk åŠ å…¥ data
        except socket.timeout: # è™•ç†è¶…æ™‚
             write_log(f"âŒ Socket timeout during receive (expected {size}, got {len(data)}).")
             raise ConnectionAbortedError("Socket timeout during receive")
        except socket.error as e: # è™•ç†å…¶ä»– Socket éŒ¯èª¤
            write_log(f"âŒ Socket error during receive: {e}")
            raise ConnectionAbortedError(f"Socket error during receive: {e}")
        return data # è¿”å›æ¥æ”¶åˆ°çš„å®Œæ•´è³‡æ–™

    def get_tetris_server_response(self):
        """é€é Socket å¾ Tetris Server ç²å–ç‹€æ…‹æ›´æ–°ã€‚"""
        try:
            # --- æŒ‰ç…§ Server çš„å”è­°ä¾åºæ¥æ”¶è³‡æ–™ ---
            is_game_over_byte = self._receive_data(1) # 1 byte: éŠæˆ²æ˜¯å¦çµæŸ (0x01=æ˜¯, 0x00=å¦)
            is_game_over = (is_game_over_byte == b'\x01')

            removed_lines_bytes = self._receive_data(4) # 4 bytes: ç¸½æ¶ˆé™¤è¡Œæ•¸ (æ•´æ•¸)
            removed_lines = int.from_bytes(removed_lines_bytes, 'big') # 'big'è¡¨ç¤ºå¤§ç«¯åº

            height_bytes = self._receive_data(4) # 4 bytes: ç•¶å‰æœ€å¤§é«˜åº¦ (æ•´æ•¸)
            height = int.from_bytes(height_bytes, 'big')

            holes_bytes = self._receive_data(4) # 4 bytes: ç•¶å‰å­”æ´æ•¸ (æ•´æ•¸)
            holes = int.from_bytes(holes_bytes, 'big')

            img_size_bytes = self._receive_data(4) # 4 bytes: æ¥ä¸‹ä¾†å½±åƒè³‡æ–™çš„å¤§å° (æ•´æ•¸)
            img_size = int.from_bytes(img_size_bytes, 'big')

            # æª¢æŸ¥å½±åƒå¤§å°æ˜¯å¦åˆç†ï¼Œé˜²æ­¢æ¥æ”¶è¶…å¤§è³‡æ–™å°è‡´è¨˜æ†¶é«”å•é¡Œ
            if img_size <= 0 or img_size > 1000000: # è¨­å®šä¸€å€‹åˆç†çš„ä¸Šé™ (ä¾‹å¦‚ 1MB)
                 write_log(f"âŒ Received invalid image size: {img_size}. Aborting receive.")
                 raise ValueError(f"Invalid image size received: {img_size}")

            img_png = self._receive_data(img_size) # æ¥æ”¶å¯¦éš›çš„å½±åƒè³‡æ–™ (PNG æ ¼å¼)

            # --- è§£ç¢¼ä¸¦é è™•ç†å½±åƒ ---
            nparr = np.frombuffer(img_png, np.uint8) # å°‡æ¥æ”¶åˆ°çš„ bytes è½‰æ›ç‚º NumPy é™£åˆ—
            # ä½¿ç”¨ OpenCV è§£ç¢¼ PNG å½±åƒï¼ŒIMREAD_COLOR ç¢ºä¿ç¸½æ˜¯è®€å–ç‚º 3 é€šé“ BGR å½±åƒ
            np_image = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
            if np_image is None: # æª¢æŸ¥è§£ç¢¼æ˜¯å¦æˆåŠŸ
                 write_log("âŒ Failed to decode image from server response.")
                 # è§£ç¢¼å¤±æ•—ï¼Œè¿”å›æœ€å¾Œå·²çŸ¥çš„ç‹€æ…‹ä¸¦æ¨™è¨˜éŠæˆ²çµæŸ
                 return True, self.lines_removed, self.current_height, self.current_holes, self.last_observation.copy()

            # å°‡å½±åƒç¸®æ”¾åˆ°æŒ‡å®šçš„è§€å¯Ÿå¤§å° (ä¾‹å¦‚ 84x84)
            # INTER_AREA é€šå¸¸é©ç”¨æ–¼ç¸®å°å½±åƒ
            resized = cv2.resize(np_image, (self.RESIZED_DIM, self.RESIZED_DIM), interpolation=cv2.INTER_AREA)
            # å°‡ BGR å½±åƒè½‰æ›ç‚ºç°åº¦åœ–
            gray = cv2.cvtColor(resized, cv2.COLOR_BGR2GRAY)
            # å¢åŠ ä¸€å€‹é€šé“ç¶­åº¦ï¼Œå¾ (H, W) è®Šæˆ (1, H, W)ï¼Œä¸¦ç¢ºä¿è³‡æ–™å‹æ…‹æ˜¯ uint8
            observation = np.expand_dims(gray, axis=0).astype(np.uint8)

            # --- å„²å­˜çµæœ ---
            # å„²å­˜ç¸®æ”¾å¾Œçš„ BGR å½±åƒï¼Œç”¨æ–¼ render() é¡¯ç¤º
            self.last_raw_render_frame = resized.copy()
            # å„²å­˜è™•ç†éçš„è§€å¯Ÿå€¼ (ç°åº¦åœ–ï¼Œé€šé“åœ¨å‰)
            self.last_observation = observation.copy()

            # è¿”å›æ‰€æœ‰å¾ Server ç²å–çš„ç‹€æ…‹
            return is_game_over, removed_lines, height, holes, observation

        except (ConnectionAbortedError, ConnectionRefusedError, ValueError) as e:
             # è™•ç†é€£ç·šä¸­æ–·ã€è¢«æ‹’çµ•æˆ–æ•¸å€¼éŒ¯èª¤ (ä¾‹å¦‚ç„¡æ•ˆå½±åƒå¤§å°)
             write_log(f"âŒ Connection/Value error getting server response: {e}. Ending episode.")
             # è¿”å›æœ€å¾Œç‹€æ…‹ä¸¦æ¨™è¨˜çµæŸ
             return True, self.lines_removed, self.current_height, self.current_holes, self.last_observation.copy()
        except Exception as e: # è™•ç†å…¶ä»–æ‰€æœ‰æœªé æœŸçš„éŒ¯èª¤
            write_log(f"âŒ Unexpected error getting server response: {e}. Ending episode.")
            # è¿”å›æœ€å¾Œç‹€æ…‹ä¸¦æ¨™è¨˜çµæŸ
            return True, self.lines_removed, self.current_height, self.current_holes, self.last_observation.copy()

    def step(self, action):
        """åŸ·è¡Œä¸€å€‹å‹•ä½œï¼Œä¸¦è¿”å›çµæœ (è§€å¯Ÿå€¼, çå‹µ, æ˜¯å¦çµ‚æ­¢, æ˜¯å¦æˆªæ–·, é™„åŠ è³‡è¨Š)ã€‚"""
        # --- ç™¼é€å‹•ä½œæŒ‡ä»¤ ---
        # å°‡é›¢æ•£çš„å‹•ä½œç·¨è™Ÿæ˜ å°„åˆ° Server çš„æŒ‡ä»¤å­—ä¸²
        command_map = {
            0: b"move -1\n", 1: b"move 1\n",   # å·¦å³ç§»å‹•
            2: b"rotate 0\n", 3: b"rotate 1\n", # æ—‹è½‰ (å‡è¨­ 0 å’Œ 1 ä»£è¡¨ä¸åŒæ–¹å‘)
            4: b"drop\n"                       # ä¸‹æ”¾åˆ°åº•
        }
        command = command_map.get(action) # æ ¹æ“š action ç²å–æŒ‡ä»¤
        if command is None: # å¦‚æœæ”¶åˆ°ç„¡æ•ˆçš„ action ç·¨è™Ÿ
            write_log(f"âš ï¸ Invalid action received: {action}. Sending 'drop'.")
            command = b"drop\n" # é è¨­ç™¼é€ 'drop' ä½œç‚ºå®‰å…¨æªæ–½

        try:
            self._send_command(command) # ç™¼é€æŒ‡ä»¤
        except (ConnectionAbortedError, ConnectionError) as e: # å¦‚æœç™¼é€å¤±æ•— (é€£ç·šå•é¡Œ)
            write_log(f"âŒ Ending episode due to send failure in step: {e}")
            terminated = True # å¿…é ˆçµ‚æ­¢é€™ä¸€å±€
            observation = self.last_observation.copy() # ä½¿ç”¨æœ€å¾Œçš„è§€å¯Ÿå€¼
            reward = self.penalty_game_over_coeff * -1 # çµ¦äºˆéŠæˆ²çµæŸçš„æ‡²ç½°
            # è¨­å®š info å­—å…¸ï¼ŒåŒ…å«ä¸€äº›æœ€çµ‚ç‹€æ…‹å’ŒéŒ¯èª¤è¨Šæ¯
            info = {'removed_lines': self.lines_removed, 'lifetime': self.lifetime, 'final_status': 'send_error'}
            # SB3 è¦æ±‚åœ¨ terminated ç‚º True æ™‚ï¼Œinfo ä¸­åŒ…å« 'terminal_observation'
            info['terminal_observation'] = observation
            # terminated=True, truncated=False (éŠæˆ²æ˜¯è‡ªç„¶çµæŸï¼Œä¸æ˜¯å› ç‚ºæ™‚é–“é™åˆ¶ç­‰åŸå› æˆªæ–·)
            return observation, reward, terminated, False, info

        # --- ç²å–åŸ·è¡Œå‹•ä½œå¾Œçš„æ–°ç‹€æ…‹ ---
        terminated, new_lines_removed, new_height, new_holes, observation = self.get_tetris_server_response()

        # --- è¨ˆç®—çå‹µ (Reward Shaping) ---
        reward = 0.0 # åˆå§‹åŒ–çå‹µç‚º 0

        # 1. è¨ˆç®—é€™æ¬¡ step æ¶ˆé™¤äº†å¤šå°‘è¡Œ
        lines_cleared_this_step = new_lines_removed - self.lines_removed
        if lines_cleared_this_step > 0:
            # ä½¿ç”¨æ¶ˆé™¤è¡Œæ•¸çš„å¹³æ–¹çµ¦äºˆçå‹µï¼Œå¤§åŠ›é¼“å‹µä¸€æ¬¡æ¶ˆé™¤å¤šè¡Œ (ä¾‹å¦‚ Tetris)
            reward += (lines_cleared_this_step ** 2) * self.reward_line_clear_coeff

        # 2. è¨ˆç®—é«˜åº¦å¢åŠ äº†å¤šå°‘ï¼Œä¸¦çµ¦äºˆæ‡²ç½°
        height_increase = new_height - self.current_height
        if height_increase > 0:
            reward -= height_increase * self.penalty_height_increase_coeff

        # 3. è¨ˆç®—å­”æ´å¢åŠ äº†å¤šå°‘ï¼Œä¸¦çµ¦äºˆæ‡²ç½°
        hole_increase = new_holes - self.current_holes
        if hole_increase > 0:
            reward -= hole_increase * self.penalty_hole_increase_coeff

        # 4. æ¯èµ°ä¸€æ­¥çµ¦äºˆå¾®å°çš„è² çå‹µï¼Œé¼“å‹µæ¨¡å‹ç›¡å¿«å®ŒæˆéŠæˆ²æˆ–æ¶ˆé™¤è¡Œ
        reward -= self.penalty_step_coeff

        # 5. å¦‚æœéŠæˆ²çµæŸ (terminated)ï¼Œçµ¦äºˆä¸€å€‹å¤§çš„è² çå‹µ
        if terminated:
            reward -= self.penalty_game_over_coeff
            # å¯é¸ï¼šåœ¨æ­¤è™•è¨˜éŒ„éŠæˆ²çµæŸçš„è¨Šæ¯ï¼Œä½†å¯èƒ½æœƒå¤ªé »ç¹ï¼Œç§»åˆ° reset æˆ–å›å‘¼å‡½æ•¸ä¸­è¨˜éŒ„æ›´å¥½
            # write_log(f"ğŸ’” Game Over! Final Lines: {new_lines_removed}, Lifetime: {self.lifetime + 1}")

        # --- æ›´æ–°ç’°å¢ƒå…§éƒ¨ç‹€æ…‹ ---
        self.lines_removed = new_lines_removed # æ›´æ–°ç´¯è¨ˆæ¶ˆé™¤è¡Œæ•¸
        self.current_height = new_height     # æ›´æ–°ç•¶å‰é«˜åº¦
        self.current_holes = new_holes       # æ›´æ–°ç•¶å‰å­”æ´æ•¸
        self.lifetime += 1                   # å¢åŠ éŠæˆ²æ­¥æ•¸è¨ˆæ•¸

        # --- æº–å‚™è¿”å› Gym æ¨™æº–æ ¼å¼çš„è³‡è¨Š ---
        # info å­—å…¸å¯ä»¥åŒ…å«ä»»ä½•ä½ æƒ³å‚³éçš„é¡å¤–é™¤éŒ¯æˆ–çµ±è¨ˆè³‡è¨Š
        info = {'removed_lines': self.lines_removed, 'lifetime': self.lifetime}
        truncated = False # åœ¨é€™å€‹ç’°å¢ƒä¸­ï¼Œæˆ‘å€‘ä¸ä½¿ç”¨ truncated (æˆªæ–·) æ¦‚å¿µ

        # é—œéµï¼å¦‚æœéŠæˆ²çµæŸ (terminated)ï¼Œå¿…é ˆåœ¨ info ä¸­åŠ å…¥ 'terminal_observation'
        # SB3 çš„æ¼”ç®—æ³• (ä¾‹å¦‚ DQN) éœ€è¦é€™å€‹è³‡è¨Šä¾†æ­£ç¢ºè¨ˆç®—æœ€å¾Œä¸€æ­¥çš„åƒ¹å€¼
        if terminated:
            info['terminal_observation'] = observation.copy()

        # å¯é¸ï¼šå¦‚æœåœ¨ step ä¸­æ¸²æŸ“ (ä¾‹å¦‚ human æ¨¡å¼)
        if self.render_mode == "human":
             self.render()

        # è¿”å› (è§€å¯Ÿå€¼, çå‹µ, æ˜¯å¦çµ‚æ­¢, æ˜¯å¦æˆªæ–·, é™„åŠ è³‡è¨Š)
        return observation, reward, terminated, truncated, info

    def reset(self, seed=None, options=None):
        """é‡ç½®ç’°å¢ƒåˆ°åˆå§‹ç‹€æ…‹ã€‚"""
        # å‘¼å«çˆ¶é¡åˆ¥çš„ resetï¼Œè™•ç† seed ç­‰æ¨™æº–åŠŸèƒ½
        super().reset(seed=seed)

        # --- å˜—è©¦èˆ‡ Server é€šè¨Šä¸¦é–‹å§‹æ–°éŠæˆ²ï¼ŒåŒ…å«é‡è©¦å’Œé‡é€£æ©Ÿåˆ¶ ---
        for attempt in range(3): # æœ€å¤šå˜—è©¦ 3 æ¬¡
            try:
                # ç™¼é€ "start" æŒ‡ä»¤çµ¦ Server
                self._send_command(b"start\n")
                # ç²å– Server è¿”å›çš„åˆå§‹ç‹€æ…‹
                terminated, lines, height, holes, observation = self.get_tetris_server_response()

                # æª¢æŸ¥ Server æ˜¯å¦åœ¨ reset å¾Œç«‹åˆ»å›å ±éŠæˆ²çµæŸ (ç•°å¸¸æƒ…æ³)
                if terminated:
                    write_log(f"âš ï¸ Server reported game over on reset attempt {attempt+1}. Retrying...")
                    if attempt < 2: # å¦‚æœä¸æ˜¯æœ€å¾Œä¸€æ¬¡å˜—è©¦
                         self._connect_socket() # å˜—è©¦é‡æ–°å»ºç«‹ Socket é€£ç·š
                         time.sleep(0.5) # ç­‰å¾…ä¸€å°æ®µæ™‚é–“å†é‡è©¦
                         continue # ç¹¼çºŒä¸‹ä¸€æ¬¡è¿´åœˆå˜—è©¦
                    else: # å¦‚æœå¤šæ¬¡å˜—è©¦å¾Œä»ç„¶å¤±æ•—
                         write_log("âŒ Server still terminated after multiple reset attempts. Cannot proceed.")
                         raise RuntimeError("Tetris server failed to reset properly.")

                # --- Reset æˆåŠŸ ---
                # é‡ç½®å…§éƒ¨çµ±è¨ˆè®Šæ•¸
                self.lines_removed = 0
                self.current_height = height # ä½¿ç”¨ Server è¿”å›çš„åˆå§‹é«˜åº¦
                self.current_holes = holes   # ä½¿ç”¨ Server è¿”å›çš„åˆå§‹å­”æ´æ•¸
                self.lifetime = 0
                self.last_observation = observation.copy() # å„²å­˜åˆå§‹è§€å¯Ÿå€¼
                # write_log(f"ğŸ”„ Environment Reset. Initial state: H={height}, O={holes}") # å¯é¸çš„è©³ç´°æ—¥èªŒ
                info = {} # reset é€šå¸¸è¿”å›ç©ºçš„ info
                return observation, info # è¿”å›åˆå§‹è§€å¯Ÿå€¼å’Œç©ºçš„ info

            except (ConnectionAbortedError, ConnectionError, socket.error, TimeoutError) as e:
                 # è™•ç† reset éç¨‹ä¸­çš„é€£ç·šç›¸é—œéŒ¯èª¤
                 write_log(f"ğŸ”Œ Connection issue during reset attempt {attempt+1} ({e}). Retrying...")
                 if attempt < 2: # å¦‚æœä¸æ˜¯æœ€å¾Œä¸€æ¬¡å˜—è©¦
                      try:
                          self._connect_socket() # å˜—è©¦é‡é€£
                          time.sleep(0.5)
                      except ConnectionError: # å¦‚æœé‡é€£ä¹Ÿå¤±æ•—
                           write_log("   Reconnect failed.")
                           # å¦‚æœç¬¬äºŒæ¬¡å˜—è©¦ä¹Ÿå¤±æ•—ï¼Œå°±æ”¾æ£„ä¸¦æ‹‹å‡ºéŒ¯èª¤
                           if attempt == 1:
                               raise RuntimeError(f"Failed to reconnect and reset Tetris server after multiple attempts: {e}")
                 else: # å¦‚æœæ˜¯æœ€å¾Œä¸€æ¬¡å˜—è©¦å¤±æ•—
                     raise RuntimeError(f"Failed to reset Tetris server after multiple attempts: {e}")

        # ç†è«–ä¸Šä¸æ‡‰è©²åŸ·è¡Œåˆ°é€™è£¡ï¼Œä½†ä½œç‚ºä¿éšª
        raise RuntimeError("Failed to reset Tetris server.")

    def render(self):
        """æ ¹æ“šè¨­å®šçš„ render_mode æ¸²æŸ“ç’°å¢ƒç‹€æ…‹ã€‚"""
        # å¦‚æœæ˜¯ human æ¨¡å¼ï¼Œç¢ºä¿ Pygame å·²åˆå§‹åŒ–
        self._initialize_pygame()

        if self.render_mode == "human" and self.is_pygame_initialized:
            # ä½¿ç”¨ Pygame é¡¯ç¤ºè¦–çª—
            import pygame # ç¢ºä¿ pygame å·²å¼•å…¥
            if self.window_surface is None: # é˜²ç¦¦æ€§æª¢æŸ¥
                 write_log("âš ï¸ Render called but Pygame window is not initialized.")
                 return

            # æª¢æŸ¥æ˜¯å¦æœ‰å¯ä¾›æ¸²æŸ“çš„å¹€
            if hasattr(self, 'last_raw_render_frame'):
                try:
                    # --- å°‡ OpenCV (BGR) å½±åƒè½‰æ›ç‚º Pygame (RGB) è¡¨é¢ ---
                    # self.last_raw_render_frame æ˜¯ (H, W, 3) çš„ BGR NumPy é™£åˆ—
                    # 1. é¡è‰²è½‰æ› BGR -> RGB
                    render_frame_rgb = cv2.cvtColor(self.last_raw_render_frame, cv2.COLOR_BGR2RGB)
                    # 2. å»ºç«‹ä¸€å€‹ Pygame Surfaceï¼Œå¤§å°èˆ‡åŸå§‹å¹€ç›¸åŒ
                    surf = pygame.Surface((self.RESIZED_DIM, self.RESIZED_DIM))
                    # 3. å°‡ NumPy é™£åˆ—ç¹ªè£½åˆ° Surface ä¸Š
                    #    pygame.surfarray.blit_array éœ€è¦ (W, H, C) çš„å½¢ç‹€ï¼Œæ‰€ä»¥è¦ transpose
                    pygame.surfarray.blit_array(surf, np.transpose(render_frame_rgb, (1, 0, 2)))
                    # 4. å°‡ Surface æ”¾å¤§åˆ°è¦–çª—å¤§å°
                    surf = pygame.transform.scale(surf, self.window_surface.get_size())
                    # 5. å°‡æ”¾å¤§å¾Œçš„ Surface ç¹ªè£½åˆ°è¦–çª—è¡¨é¢ä¸Š
                    self.window_surface.blit(surf, (0, 0))
                    # --- æ›´æ–°é¡¯ç¤ºèˆ‡æ§åˆ¶å¹€ç‡ ---
                    pygame.event.pump() # è™•ç† Pygame å…§éƒ¨äº‹ä»¶ä½‡åˆ—
                    pygame.display.flip() # å°‡ç¹ªè£½çš„å…§å®¹æ›´æ–°åˆ°è¢å¹•ä¸Š
                    self.clock.tick(self.metadata["render_fps"]) # æ ¹æ“šè¨­å®šçš„ FPS æ§åˆ¶è¿´åœˆé€Ÿåº¦
                except Exception as e: # è™•ç†æ¸²æŸ“éç¨‹ä¸­çš„éŒ¯èª¤
                    write_log(f"âš ï¸ Error during Pygame rendering: {e}")
            else:
                # å¦‚æœé‚„æ²’æœ‰æ”¶åˆ°ä»»ä½•å¹€ï¼Œé¡¯ç¤ºé»‘è‰²ç•«é¢
                 self.window_surface.fill((0, 0, 0))
                 pygame.display.flip()

        elif self.render_mode == "rgb_array":
             # ç›´æ¥è¿”å›å½±åƒé™£åˆ— (é€šå¸¸ç”¨æ–¼éŒ„è£½å½±ç‰‡æˆ–åœ¨ç„¡é ­ç’°å¢ƒä¸­ä½¿ç”¨)
             if hasattr(self, 'last_raw_render_frame'):
                 # è¿”å› (H, W, 3) çš„ RGB NumPy é™£åˆ—
                 return cv2.cvtColor(self.last_raw_render_frame, cv2.COLOR_BGR2RGB)
             else:
                 # å¦‚æœé‚„æ²’æœ‰å¹€ï¼Œè¿”å›ä¸€å€‹é»‘è‰²ç•«é¢çš„é™£åˆ—
                 return np.zeros((self.RESIZED_DIM, self.RESIZED_DIM, 3), dtype=np.uint8)

    def close(self):
        """é—œé–‰ç’°å¢ƒï¼Œé‡‹æ”¾è³‡æºã€‚"""
        # é—œé–‰ Socket é€£ç·š
        if self.client_sock:
            try:
                self.client_sock.close()
            except socket.error as e:
                 write_log(f"   Error closing socket: {e}")
            self.client_sock = None
        # é—œé–‰ Pygame è¦–çª—å’Œæ¨¡çµ„
        if self.is_pygame_initialized:
            try:
                import pygame
                pygame.display.quit()
                pygame.quit()
                self.is_pygame_initialized = False
            except Exception as e:
                 write_log(f"   Error closing Pygame: {e}")

# --- ç’°å¢ƒè¨­å®š (è¨“ç·´ç”¨) ---
write_log("âœ… å»ºç«‹åŸºç¤ç’°å¢ƒå‡½æ•¸ make_env...")
def make_env():
    """è¼”åŠ©å‡½æ•¸ï¼Œç”¨æ–¼å»ºç«‹ä¸€å€‹ TetrisEnv å¯¦ä¾‹ã€‚"""
    env = TetrisEnv()
    return env

write_log("âœ… å»ºç«‹å‘é‡åŒ–ç’°å¢ƒ (DummyVecEnv)...")
# å› ç‚º Java Server é€šå¸¸åªæ¥å—ä¸€å€‹å®¢æˆ¶ç«¯é€£ç·šï¼Œæ‰€ä»¥ä½¿ç”¨ DummyVecEnv
# å®ƒåªæ˜¯ç°¡å–®åœ°åœ¨å–®ä¸€é€²ç¨‹ä¸­ä¾åºåŸ·è¡Œç’°å¢ƒï¼Œæä¾› VecEnv ä»‹é¢
train_env_base = DummyVecEnv([make_env])

write_log("âœ… åŒ…è£ç’°å¢ƒ (VecFrameStack)...")
# VecFrameStackï¼šå°‡é€£çºŒ n_stack å¹€çš„è§€å¯Ÿå€¼å †ç–Šåœ¨ä¸€èµ·
# é€™è®“åŸºæ–¼ CNN çš„ç­–ç•¥èƒ½ç²å–ç‰©é«”é‹å‹•çš„æ™‚åºè³‡è¨Š
# channels_order="first" è¡¨ç¤ºå †ç–Šå¾Œçš„é€šé“ç¶­åº¦åœ¨å‰ (C, H, W)ï¼Œç¬¦åˆ PyTorch è¦æ±‚
n_stack = run.config["n_stack"] if run else 4 # å¾ wandb config ç²å– n_stackï¼Œè‹¥ç„¡å‰‡ç”¨é è¨­å€¼ 4
train_env_stacked = VecFrameStack(train_env_base, n_stack=n_stack, channels_order="first")

write_log("âœ… åŒ…è£ç’°å¢ƒ (VecNormalize - Rewards Only)...")
# VecNormalizeï¼šç”¨æ–¼æ¨™æº–åŒ–è§€å¯Ÿå€¼å’Œ/æˆ–çå‹µ
# æ¨™æº–åŒ–çå‹µ (norm_reward=True) é€šå¸¸æœ‰åŠ©æ–¼ç©©å®š DQN ç­‰æ¼”ç®—æ³•çš„å­¸ç¿’ï¼Œå› ç‚ºå®ƒèƒ½æ§åˆ¶çå‹µçš„ç¯„åœ
# æ¨™æº–åŒ–è§€å¯Ÿå€¼ (norm_obs=True) å°æ–¼ MLP ç­–ç•¥å¾ˆé‡è¦ï¼Œä½†å°æ–¼ CNN ç­–ç•¥ (CnnPolicy)ï¼Œ
#   SB3 çš„ CnnPolicy å…§éƒ¨é€šå¸¸æœƒè‡ªå·±è™•ç†å½±åƒçš„æ¨™æº–åŒ–/ç¸®æ”¾ï¼Œæˆ–è€…å¯ä»¥é€é policy_kwargs æ§åˆ¶ã€‚
#   é€™è£¡æ ¹æ“šåŸå§‹ç¨‹å¼ç¢¼å’Œå¸¸è¦‹åšæ³•ï¼Œè¨­å®š norm_obs=Falseï¼Œåªæ¨™æº–åŒ–çå‹µã€‚
# gammaï¼šéœ€è¦å°‡è¨“ç·´æ™‚ä½¿ç”¨çš„æŠ˜æ‰£å› å­ gamma å‚³éçµ¦ VecNormalizeï¼Œå®ƒæœƒç”¨ä¾†è¨ˆç®—ç´¯ç©çå‹µçš„ç§»å‹•å¹³å‡
gamma = run.config["gamma"] if run else 0.99 # å¾ wandb config ç²å– gamma
train_env = VecNormalize(train_env_stacked, norm_obs=False, norm_reward=True, gamma=gamma)

write_log("   ç’°å¢ƒå»ºç«‹å®Œæˆä¸¦å·²åŒ…è£ (DummyVecEnv -> VecFrameStack -> VecNormalize)")

# ----------------------------
# DQN æ¨¡å‹è¨­å®šèˆ‡è¨“ç·´
# ----------------------------
write_log("ğŸ§  è¨­å®š DQN æ¨¡å‹...")
# --- å¾ Wandb Config æˆ–ä½¿ç”¨é è¨­å€¼ç²å–è¶…åƒæ•¸ ---
# é€™æ¨£å¯ä»¥æ–¹ä¾¿åœ°é€é Wandb UI ä¾†èª¿æ•´å’Œè¿½è¹¤å¯¦é©—çš„è¶…åƒæ•¸è¨­å®š
policy_type = run.config["policy_type"] if run else "CnnPolicy"
learning_rate = run.config["learning_rate"] if run else 1e-4
buffer_size = run.config["buffer_size"] if run else 100000 # ç¶“é©—å›æ”¾ç·©è¡å€å¤§å°
learning_starts = run.config["learning_starts"] if run else 10000 # é–‹å§‹å­¸ç¿’å‰æ”¶é›†çš„æ­¥æ•¸
batch_size = run.config["batch_size"] if run else 32 # æ¯æ¬¡æ¢¯åº¦æ›´æ–°çš„æ¨£æœ¬æ•¸
tau = 1.0 # DQN ä¸­ Target Network çš„è»Ÿæ›´æ–°ä¿‚æ•¸ (Ï„)ï¼Œ1.0 ä»£è¡¨ç¡¬æ›´æ–° (Hard Update)
target_update_interval = run.config["target_update_interval"] if run else 10000 # Target Network æ›´æ–°é »ç‡ (æ­¥æ•¸)
gradient_steps = 1 # æ¯æ¬¡ train_freq è§¸ç™¼æ™‚åŸ·è¡Œçš„æ¢¯åº¦æ›´æ–°æ¬¡æ•¸
# æ¢ç´¢ç‡ (Epsilon-Greedy) ç›¸é—œåƒæ•¸
exploration_fraction = run.config["exploration_fraction"] if run else 0.1 # é è¨­ DQN çš„æ¢ç´¢è¡°æ¸›è¼ƒå¿«
exploration_final_eps = run.config["exploration_final_eps"] if run else 0.05 # æ¢ç´¢ç‡æœ€çµ‚å€¼

# --- å»ºç«‹ DQN æ¨¡å‹ ---
model = DQN(
    policy=policy_type,                   # ç­–ç•¥é¡å‹ ("CnnPolicy" ä½¿ç”¨å…§å»ºçš„ CNN ç‰¹å¾µæå–å™¨)
    env=train_env,                        # è¨“ç·´ç’°å¢ƒ (å·²ç¶“é VecFrameStack å’Œ VecNormalize åŒ…è£)
    verbose=1,                            # è¨­å®šæ—¥èªŒè©³ç´°ç¨‹åº¦ (1: é¡¯ç¤ºè¨“ç·´é€²åº¦)
    gamma=gamma,                          # æŠ˜æ‰£å› å­
    learning_rate=learning_rate,          # å­¸ç¿’ç‡
    buffer_size=buffer_size,              # Replay Buffer å¤§å°
    learning_starts=learning_starts,      # é–‹å§‹å­¸ç¿’çš„æ­¥æ•¸
    batch_size=batch_size,                # æ‰¹æ¬¡å¤§å°
    tau=tau,                              # Target Network æ›´æ–°ä¿‚æ•¸
    train_freq=(1, "step"),               # è¨“ç·´é »ç‡ (æ¯ 1 æ­¥è¨“ç·´ 1 æ¬¡)
    gradient_steps=gradient_steps,        # æ¯æ¬¡è¨“ç·´åŸ·è¡Œçš„æ¢¯åº¦æ›´æ–°æ­¥æ•¸
    target_update_interval=target_update_interval, # Target Network æ›´æ–°é–“éš” (æ­¥æ•¸)
    exploration_fraction=exploration_fraction,     # æ¢ç´¢ç‡è¡°æ¸›æ‰€ä½”çš„ç¸½æ­¥æ•¸æ¯”ä¾‹
    exploration_final_eps=exploration_final_eps,   # æœ€çµ‚æ¢ç´¢ç‡
    # policy_kwargs ç”¨æ–¼å‚³éé¡å¤–åƒæ•¸çµ¦ Policy é¡åˆ¥
    # normalize_images=False æ ¹æ“šåŸå§‹ç¨‹å¼ç¢¼è¨­å®šï¼ŒSB3 CnnPolicy é€šå¸¸æœƒåšåŸºæœ¬ç¸®æ”¾ï¼Œ
    # é€™å€‹ flag çš„å…·é«”ä½œç”¨å¯èƒ½éœ€è¦æŸ¥é–± SB3 åŸå§‹ç¢¼ç¢ºèªï¼Œä½†æˆ‘å€‘å…ˆä¿ç•™å®ƒã€‚
    policy_kwargs=dict(normalize_images=False),
    seed=42,                              # è¨­å®šéš¨æ©Ÿç¨®å­ä»¥ä¿è­‰å¯é‡è¤‡æ€§
    device="cuda" if torch.cuda.is_available() else "cpu", # è‡ªå‹•é¸æ“‡ GPU æˆ– CPU
    # å¦‚æœ Wandb å•Ÿç”¨ï¼Œè¨­å®š TensorBoard æ—¥èªŒè·¯å¾‘ï¼ŒWandbCallback æœƒè®€å–é€™è£¡çš„æ—¥èªŒ
    tensorboard_log=f"/kaggle/working/runs/{run_id}" if wandb_enabled else None
)
write_log(f"   æ¨¡å‹å»ºç«‹å®Œæˆ. Device: {model.device}") # é¡¯ç¤ºæ¨¡å‹ä½¿ç”¨çš„è£ç½®
if run: write_log(f"   ä½¿ç”¨ Wandb è¶…åƒæ•¸: {run.config}") # é¡¯ç¤ºä½¿ç”¨çš„è¶…åƒæ•¸ä¾†æº
else: write_log("   ä½¿ç”¨é»˜èªè¶…åƒæ•¸ (Wandb æœªå•Ÿç”¨).")

# --- è¨­å®šå›å‘¼å‡½æ•¸ (Callback) ---
# å›å‘¼å‡½æ•¸å¯ä»¥åœ¨è¨“ç·´éç¨‹ä¸­çš„ç‰¹å®šé»åŸ·è¡Œè‡ªè¨‚ç¨‹å¼ç¢¼ (ä¾‹å¦‚è¨˜éŒ„ã€å„²å­˜æ¨¡å‹)
if wandb_enabled:
    # ä½¿ç”¨ Wandb æä¾›çš„å›å‘¼å‡½æ•¸
    wandb_callback = WandbCallback(
        gradient_save_freq=10000, # æ¯éš”å¤šå°‘æ­¥å„²å­˜ä¸€æ¬¡æ¢¯åº¦ç›´æ–¹åœ– (ç”¨æ–¼é™¤éŒ¯)
        # è¨­å®šæ¨¡å‹æª¢æŸ¥é»çš„å„²å­˜è·¯å¾‘å’Œé »ç‡
        model_save_path=f"/kaggle/working/models/{run_id}", # æœ¬åœ°å„²å­˜è·¯å¾‘
        model_save_freq=50000, # æ¯éš”å¤šå°‘æ­¥å„²å­˜ä¸€æ¬¡æ¨¡å‹
        log="all", # è¨˜éŒ„æ‰€æœ‰å¯ç”¨è³‡è¨Š (æ¢¯åº¦ã€ç¶²è·¯æ¬Šé‡ç›´æ–¹åœ–ç­‰)
        verbose=2 # é¡¯ç¤ºæ›´è©³ç´°çš„å›å‘¼å‡½æ•¸æ—¥èªŒ
    )
    callback_list = [wandb_callback] # å°‡å›å‘¼å‡½æ•¸æ”¾å…¥åˆ—è¡¨
else:
    callback_list = None # å¦‚æœ Wandb æœªå•Ÿç”¨ï¼Œå‰‡ä¸ä½¿ç”¨å›å‘¼å‡½æ•¸

# --- é–‹å§‹è¨“ç·´ ---
write_log(f"ğŸš€ é–‹å§‹è¨“ç·´ {TOTAL_TIMESTEPS} æ­¥...")
training_successful = False # æ¨™è¨˜è¨“ç·´æ˜¯å¦æˆåŠŸå®Œæˆ
try:
    # å‘¼å« model.learn() é–‹å§‹è¨“ç·´
    model.learn(
        total_timesteps=TOTAL_TIMESTEPS, # ç¸½è¨“ç·´æ­¥æ•¸
        callback=callback_list,          # å‚³å…¥å›å‘¼å‡½æ•¸åˆ—è¡¨
        log_interval=10                  # æ¯éš” 10 å±€éŠæˆ² (episode) åœ¨æ§åˆ¶å°è¼¸å‡ºä¸€æ¬¡åŸºæœ¬è¨“ç·´è³‡è¨Š (çå‹µç­‰)
    )
    write_log("âœ… è¨“ç·´å®Œæˆ!")
    training_successful = True # æ¨™è¨˜è¨“ç·´æˆåŠŸ
except Exception as e:
     # æ•æ‰è¨“ç·´éç¨‹ä¸­çš„ä»»ä½•éŒ¯èª¤
     write_log(f"âŒ è¨“ç·´éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤: {e}", exc_info=True) # è¨˜éŒ„è©³ç´°éŒ¯èª¤è³‡è¨Š
     # åœ¨ç™¼ç”ŸéŒ¯èª¤æ™‚ï¼Œå˜—è©¦å„²å­˜ç•¶å‰çš„æ¨¡å‹ç‹€æ…‹ï¼Œä»¥ä¾¿å¾ŒçºŒåˆ†ææˆ–ç¹¼çºŒè¨“ç·´
     error_save_path = f'/kaggle/working/{STUDENT_ID}_dqn_error_save.zip'
     try:
        model.save(error_save_path)
        write_log(f"   æ¨¡å‹å·²å˜—è©¦å„²å­˜è‡³ {error_save_path}")
        # å¦‚æœ Wandb å•Ÿç”¨ï¼Œä¹Ÿä¸Šå‚³é€™å€‹éŒ¯èª¤æ™‚å„²å­˜çš„æ¨¡å‹
        if wandb_enabled: wandb.save(error_save_path)
     except Exception as save_e: # å¦‚æœé€£å„²å­˜æ¨¡å‹éƒ½å¤±æ•—
         write_log(f"   âŒ å„²å­˜éŒ¯èª¤æ¨¡å‹æ™‚ä¹Ÿç™¼ç”ŸéŒ¯èª¤: {save_e}")
     # å¦‚æœ Wandb run æ­£åœ¨é‹è¡Œï¼Œå°‡å…¶æ¨™è¨˜ç‚ºå¤±æ•—ä¸¦çµæŸ
     if run and run.is_running: run.finish(exit_code=1, quiet=True)

# --- å„²å­˜æœ€çµ‚æ¨¡å‹ (åƒ…åœ¨è¨“ç·´æˆåŠŸå®Œæˆæ™‚åŸ·è¡Œ) ---
if training_successful:
    # å®šç¾© VecNormalize çµ±è¨ˆæ•¸æ“šå’Œæœ€çµ‚æ¨¡å‹çš„å„²å­˜è·¯å¾‘
    stats_path = f"/kaggle/working/vecnormalize_stats_{run_id}.pkl"
    final_model_name = f'{STUDENT_ID}_dqn_final_{run_id}.zip'
    final_model_path = os.path.join("/kaggle/working", final_model_name)

    try:
        # é—œéµï¼å„²å­˜ VecNormalize çš„çµ±è¨ˆæ•¸æ“š (å¹³å‡å€¼ã€è®Šç•°æ•¸ç­‰)
        # é€™äº›æ•¸æ“šåœ¨ä¹‹å¾Œè¼‰å…¥æ¨¡å‹é€²è¡Œè©•ä¼°æˆ–æ¨è«–æ™‚æ˜¯å¿…éœ€çš„
        train_env.save(stats_path)
        write_log(f"   VecNormalize çµ±è¨ˆæ•¸æ“šå·²å„²å­˜è‡³ {stats_path}")
        if wandb_enabled: wandb.save(stats_path) # ä¸Šå‚³åˆ° Wandb

        # å„²å­˜è¨“ç·´å¥½çš„ DQN æ¨¡å‹
        model.save(final_model_path)
        write_log(f"âœ… æœ€çµ‚æ¨¡å‹å·²å„²å­˜: {final_model_path}")
        display(FileLink(final_model_path)) # åœ¨ Jupyter ä¸­é¡¯ç¤ºä¸‹è¼‰é€£çµ
        if wandb_enabled: wandb.save(final_model_path) # ä¸Šå‚³åˆ° Wandb

    except Exception as e: # è™•ç†å„²å­˜éç¨‹ä¸­çš„éŒ¯èª¤
        write_log(f"âŒ å„²å­˜æœ€çµ‚æ¨¡å‹æˆ–çµ±è¨ˆæ•¸æ“šæ™‚å‡ºéŒ¯: {e}")
        training_successful = False # å¦‚æœå„²å­˜å¤±æ•—ï¼Œä¹Ÿæ¨™è¨˜ç‚ºä¸æˆåŠŸ

# ----------------------------
# è©•ä¼° (Evaluation) (åƒ…åœ¨è¨“ç·´å’Œå„²å­˜æˆåŠŸæ™‚åŸ·è¡Œ)
# ----------------------------
if training_successful:
    write_log("\nğŸ§ª é–‹å§‹è©•ä¼°è¨“ç·´å¾Œçš„æ¨¡å‹...")

    # --- å»ºç«‹è©•ä¼°ç’°å¢ƒ (é‡é»ï¼šçµæ§‹éœ€èˆ‡è¨“ç·´æ™‚åŒ¹é…) ---
    eval_env = None # åˆå§‹åŒ–ç‚º None
    try:
        # 1. å»ºç«‹åŸºç¤çš„å‘é‡åŒ–ç’°å¢ƒ
        eval_env_base = DummyVecEnv([make_env])

        # 2. å¥—ç”¨ VecFrameStack (åƒæ•¸éœ€èˆ‡è¨“ç·´æ™‚ç›¸åŒ)
        n_stack_eval = run.config["n_stack"] if run else 4
        eval_env_stacked = VecFrameStack(eval_env_base, n_stack=n_stack_eval, channels_order="first")

        # 3. è¼‰å…¥è¨“ç·´æ™‚å„²å­˜çš„ VecNormalize çµ±è¨ˆæ•¸æ“š
        #    å°‡çµ±è¨ˆæ•¸æ“šæ‡‰ç”¨åˆ° 'eval_env_stacked' ä¸Š
        eval_env = VecNormalize.load(stats_path, eval_env_stacked)

        # 4. è¨­å®š VecNormalize çš„æ¨¡å¼ç‚ºè©•ä¼°æ¨¡å¼
        eval_env.training = False    # ä¸å†æ›´æ–°ç§»å‹•å¹³å‡å’Œè®Šç•°æ•¸
        eval_env.norm_reward = False # **ä¸**æ¨™æº–åŒ–çå‹µï¼Œé€™æ¨£æ‰èƒ½çœ‹åˆ°çœŸå¯¦çš„åŸå§‹çå‹µåˆ†æ•¸

        write_log("   è©•ä¼°ç’°å¢ƒå»ºç«‹æˆåŠŸ.")

    except FileNotFoundError: # å¦‚æœæ‰¾ä¸åˆ°çµ±è¨ˆæª”æ¡ˆ
        write_log(f"âŒ éŒ¯èª¤: VecNormalize çµ±è¨ˆæ–‡ä»¶æœªæ‰¾åˆ°æ–¼ {stats_path}ã€‚è·³éè©•ä¼°ã€‚")
        eval_env = None
    except Exception as e: # è™•ç†å»ºç«‹è©•ä¼°ç’°å¢ƒæ™‚çš„å…¶ä»–éŒ¯èª¤
        write_log(f"âŒ å»ºç«‹è©•ä¼°ç’°å¢ƒæ™‚å‡ºéŒ¯: {e}")
        eval_env = None

    # --- åŸ·è¡Œè©•ä¼°è¿´åœˆ (åƒ…åœ¨è©•ä¼°ç’°å¢ƒæˆåŠŸå»ºç«‹æ™‚) ---
    if eval_env is not None:
        num_eval_episodes = 5 # è¨­å®šè¦è©•ä¼°å¤šå°‘å±€éŠæˆ²
        total_rewards = []    # å„²å­˜æ¯å±€çš„ç¸½çå‹µ
        total_lines = []      # å„²å­˜æ¯å±€çš„æœ€çµ‚æ¶ˆé™¤è¡Œæ•¸
        total_lifetimes = []  # å„²å­˜æ¯å±€çš„ç¸½æ­¥æ•¸
        all_frames = []       # å„²å­˜ç¬¬ä¸€å±€éŠæˆ²çš„æ‰€æœ‰å¹€ï¼Œç”¨æ–¼è£½ä½œ GIF

        try:
            for i in range(num_eval_episodes): # è¿´åœˆåŸ·è¡Œ N å±€éŠæˆ²
                obs = eval_env.reset() # é‡ç½®ç’°å¢ƒï¼Œç²å–åˆå§‹è§€å¯Ÿå€¼
                done = False           # æ¨™è¨˜éŠæˆ²æ˜¯å¦çµæŸ
                episode_reward = 0     # åˆå§‹åŒ–ç•¶å±€çå‹µ
                episode_lines = 0      # åˆå§‹åŒ–ç•¶å±€è¡Œæ•¸
                episode_lifetime = 0   # åˆå§‹åŒ–ç•¶å±€æ­¥æ•¸
                frames = []            # åˆå§‹åŒ–ç•¶å±€çš„å¹€åˆ—è¡¨
                last_info = {}         # åˆå§‹åŒ–æœ€å¾Œä¸€æ­¥çš„ info

                while not done: # åœ¨ä¸€å±€éŠæˆ²çµæŸå‰æŒçºŒåŸ·è¡Œ
                    # --- ç²å–ç”¨æ–¼æ¸²æŸ“ GIF çš„åŸå§‹å¹€ ---
                    # éœ€è¦è¨ªå•è¢«å±¤å±¤åŒ…è£çš„åŸå§‹ TetrisEnv å¯¦ä¾‹
                    try:
                         # eval_env(VecNormalize) -> eval_env_stacked(VecFrameStack) -> eval_env_base(DummyVecEnv) -> TetrisEnv
                         base_env = eval_env.get_attr("envs")[0].env # ç²å–åŸå§‹ TetrisEnv
                         raw_frame = base_env.render(mode="rgb_array") # å‘¼å«å…¶ render æ–¹æ³•
                         # åªè¨˜éŒ„ç¬¬ä¸€å±€çš„å¹€
                         if i == 0: frames.append(raw_frame)
                    except Exception as render_err:
                         write_log(f"âš ï¸ è©•ä¼°æ™‚ç²å–æ¸²æŸ“å¹€å‡ºéŒ¯: {render_err}")

                    # --- é æ¸¬å‹•ä½œä¸¦åŸ·è¡Œ ---
                    # ä½¿ç”¨è¨“ç·´å¥½çš„æ¨¡å‹ 'model' ä¾†é æ¸¬å‹•ä½œ
                    # deterministic=True è¡¨ç¤ºä¸åŠ å…¥ä»»ä½•æ¢ç´¢é›œè¨Šï¼Œæ¡å–æ¨¡å‹èªç‚ºæœ€å„ªçš„å‹•ä½œ
                    action, _ = model.predict(obs, deterministic=True)
                    # åœ¨è©•ä¼°ç’°å¢ƒä¸­åŸ·è¡Œå‹•ä½œ
                    obs, reward, done, infos = eval_env.step(action)

                    # --- ç´¯è¨ˆçå‹µå’Œçµ±è¨ˆæ•¸æ“š ---
                    # reward æ˜¯ VecEnv è¿”å›çš„åˆ—è¡¨ (å³ä½¿åªæœ‰ä¸€å€‹ç’°å¢ƒ)ï¼Œå–ç¬¬ä¸€å€‹å…ƒç´ 
                    # ç”±æ–¼ eval_env.norm_reward = Falseï¼Œé€™è£¡çš„ reward æ˜¯æœªç¶“æ¨™æº–åŒ–çš„åŸå§‹çå‹µ
                    episode_reward += reward[0]
                    # infos ä¹Ÿæ˜¯åˆ—è¡¨ï¼Œå–ç¬¬ä¸€å€‹å…ƒç´ çš„ info å­—å…¸
                    last_info = infos[0]
                    # å¾ info ä¸­å®‰å…¨åœ°ç²å– 'removed_lines' å’Œ 'lifetime'
                    # ä½¿ç”¨ .get(key, default) é¿å…å›  key ä¸å­˜åœ¨è€Œå‡ºéŒ¯
                    episode_lines = last_info.get('removed_lines', episode_lines)
                    episode_lifetime = last_info.get('lifetime', episode_lifetime)
                    # done ä¹Ÿæ˜¯åˆ—è¡¨ï¼Œå–ç¬¬ä¸€å€‹å…ƒç´ 
                    done = done[0]

                # --- ä¸€å±€éŠæˆ²çµæŸå¾Œè¨˜éŒ„çµ±è¨ˆæ•¸æ“š ---
                write_log(f"   è©•ä¼° Episode {i+1}: Reward={episode_reward:.2f}, Lines={episode_lines}, Steps={episode_lifetime}")
                total_rewards.append(episode_reward)
                total_lines.append(episode_lines)
                total_lifetimes.append(episode_lifetime)
                # å¦‚æœæ˜¯ç¬¬ä¸€å±€ï¼Œå„²å­˜æ”¶é›†åˆ°çš„å¹€
                if i == 0: all_frames = frames

            # --- è¨ˆç®—ä¸¦é¡¯ç¤ºå¹³å‡è©•ä¼°çµæœ ---
            write_log(f"--- è©•ä¼°çµæœ ({num_eval_episodes} episodes) ---")
            mean_reward = np.mean(total_rewards) if total_rewards else 0
            std_reward = np.std(total_rewards) if total_rewards else 0
            mean_lines = np.mean(total_lines) if total_lines else 0
            std_lines = np.std(total_lines) if total_lines else 0
            mean_lifetime = np.mean(total_lifetimes) if total_lifetimes else 0
            std_lifetime = np.std(total_lifetimes) if total_lifetimes else 0

            write_log(f"   å¹³å‡ Reward: {mean_reward:.2f} +/- {std_reward:.2f}")
            write_log(f"   å¹³å‡ Lines: {mean_lines:.2f} +/- {std_lines:.2f}")
            write_log(f"   å¹³å‡ Steps: {mean_lifetime:.2f} +/- {std_lifetime:.2f}")

            # --- å°‡è©•ä¼°çµæœè¨˜éŒ„åˆ° Wandb ---
            if wandb_enabled:
                wandb.log({
                    "eval/mean_reward": mean_reward, "eval/std_reward": std_reward,
                    "eval/mean_lines": mean_lines, "eval/std_lines": std_lines,
                    "eval/mean_lifetime": mean_lifetime, "eval/std_lifetime": std_lifetime,
                })

            # --- ç”Ÿæˆä¸¦å„²å­˜å›æ”¾ GIF (å¾ç¬¬ä¸€å±€è©•ä¼°) ---
            if all_frames: # ç¢ºä¿æœ‰æ”¶é›†åˆ°å¹€
                gif_path = f'/kaggle/working/replay_eval_{run_id}.gif'
                write_log(f"ğŸ’¾ æ­£åœ¨å„²å­˜è©•ä¼°å›æ”¾ GIF è‡³ {gif_path}...")
                try:
                    # ä½¿ç”¨ imageio å°‡å¹€åˆ—è¡¨å„²å­˜ç‚º GIF
                    # ç¢ºä¿å¹€æ˜¯ uint8 å‹æ…‹
                    imageio.mimsave(gif_path, [np.array(frame).astype(np.uint8) for frame in all_frames], fps=15, loop=0)
                    write_log("   GIF å„²å­˜æˆåŠŸ.")
                    display(FileLink(gif_path)) # é¡¯ç¤ºä¸‹è¼‰é€£çµ
                    # å¦‚æœ Wandb å•Ÿç”¨ï¼Œå°‡ GIF ä½œç‚ºå½±ç‰‡ä¸Šå‚³
                    if wandb_enabled: wandb.log({"eval/replay": wandb.Video(gif_path, fps=15, format="gif")})
                except Exception as e: write_log(f"   âŒ å„²å­˜ GIF æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
            else: write_log("   âš ï¸ æœªèƒ½å„²å­˜ GIF (æ²’æœ‰æ”¶é›†åˆ°å¹€).")

            # --- å„²å­˜è©•ä¼°çµæœåˆ° CSV æª”æ¡ˆ ---
            csv_filename = f'tetris_evaluation_scores_{run_id}.csv'
            csv_path = os.path.join("/kaggle/working", csv_filename)
            try:
                with open(csv_path, 'w') as fs:
                    fs.write('episode_id,removed_lines,played_steps,reward\n') # å¯«å…¥æ¨™é ­
                    # è¨˜éŒ„ç¬¬ä¸€å±€çš„è©³ç´°æ•¸æ“š (å¦‚æœå­˜åœ¨)
                    if total_lines:
                        fs.write(f'eval_0,{total_lines[0]},{total_lifetimes[0]},{total_rewards[0]:.2f}\n')
                    # è¨˜éŒ„å¹³å‡æ•¸æ“š
                    fs.write(f'eval_avg,{mean_lines:.2f},{mean_lifetime:.2f},{mean_reward:.2f}\n')
                write_log(f"âœ… è©•ä¼°åˆ†æ•¸ CSV å·²å„²å­˜: {csv_path}")
                display(FileLink(csv_path)) # é¡¯ç¤ºä¸‹è¼‰é€£çµ
                if wandb_enabled: wandb.save(csv_path) # ä¸Šå‚³ CSV åˆ° Wandb
            except Exception as e: write_log(f"   âŒ å„²å­˜ CSV æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

        except Exception as eval_e: # æ•æ‰è©•ä¼°è¿´åœˆä¸­çš„å…¶ä»–éŒ¯èª¤
            write_log(f"âŒ è©•ä¼°è¿´åœˆä¸­ç™¼ç”ŸéŒ¯èª¤: {eval_e}", exc_info=True)

        finally:
             # ç„¡è«–è©•ä¼°è¿´åœˆæ˜¯å¦æˆåŠŸï¼Œéƒ½ç¢ºä¿é—œé–‰è©•ä¼°ç’°å¢ƒ
             if eval_env:
                 eval_env.close()
                 write_log("   è©•ä¼°ç’°å¢ƒå·²é—œé–‰.")

# --- æ¸…ç† (Cleanup) ---
write_log("ğŸ§¹ æ¸…ç†ç’°å¢ƒ...")
# é—œé–‰è¨“ç·´ç’°å¢ƒ (å¦‚æœå®ƒå­˜åœ¨)
if 'train_env' in locals() and train_env:
    train_env.close()
    write_log("   è¨“ç·´ç’°å¢ƒå·²é—œé–‰.")
# é—œé–‰ Java Server é€²ç¨‹ (å¦‚æœå®ƒé‚„åœ¨é‹è¡Œ)
if java_process and java_process.poll() is None: # .poll() is None è¡¨ç¤ºé€²ç¨‹ä»åœ¨é‹è¡Œ
     write_log("   æ­£åœ¨çµ‚æ­¢ Java server process...")
     java_process.terminate() # å˜—è©¦æ­£å¸¸çµ‚æ­¢
     try:
         java_process.wait(timeout=5) # ç­‰å¾…æœ€å¤š 5 ç§’è®“å…¶çµæŸ
         write_log("   Java server process å·²çµ‚æ­¢.")
     except subprocess.TimeoutExpired: # å¦‚æœè¶…æ™‚
         write_log("   Java server æœªèƒ½åœ¨ 5 ç§’å…§çµ‚æ­¢, å¼·åˆ¶çµæŸ...")
         java_process.kill() # å¼·åˆ¶çµæŸ
         write_log("   Java server process å·²å¼·åˆ¶çµæŸ.")
elif java_process and java_process.poll() is not None: # å¦‚æœé€²ç¨‹å·²çµæŸ
     write_log("   Java server process å·²è‡ªè¡ŒçµæŸ.")
else: # å¦‚æœä¸€é–‹å§‹å°±æ²’æˆåŠŸå•Ÿå‹•
     write_log("   Java server process æœªå•Ÿå‹•æˆ–å·²é—œé–‰.")


# --- çµæŸ Wandb Run ---
# åƒ…åœ¨ Wandb å•Ÿç”¨ä¸”è¨“ç·´æœªåœ¨æ—©æœŸå´©æ½°æ™‚åŸ·è¡Œ
if run:
    if training_successful: # å¦‚æœè¨“ç·´æ­£å¸¸å®Œæˆ
         run.finish()
         write_log("âœ¨ Wandb run finished.")
    else: # å¦‚æœè¨“ç·´ä¸­é€”å‡ºéŒ¯
         # æª¢æŸ¥ run æ˜¯å¦ä»åœ¨é‹è¡Œ (å¯èƒ½åœ¨éŒ¯èª¤è™•ç†ä¸­å·²è¢«çµæŸ)
         if run.is_running:
              run.finish(exit_code=1) # ç¢ºä¿å°‡ run æ¨™è¨˜ç‚ºå¤±æ•—
         write_log("âœ¨ Wandb run finished (marked as failed due to error).")

write_log("ğŸ è…³æœ¬åŸ·è¡Œå®Œç•¢.")